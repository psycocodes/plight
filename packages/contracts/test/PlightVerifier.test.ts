import { expect } from "chai";
import { ethers } from "hardhat";
import fs from "fs";
import path from "path";

describe("PlightVerifier", function () {
    let verifierAddress: string;
    let plightVerifier: any;

    before(async function () {
        // 1. Deploy generic Verifier (Groth16)
        const VerifierFactory = await ethers.getContractFactory("Verifier");
        const verifierContract = await VerifierFactory.deploy();
        await verifierContract.waitForDeployment();
        verifierAddress = await verifierContract.getAddress();

        // 2. Deploy Wrapper
        const PlightVerifierFactory = await ethers.getContractFactory("PlightVerifier");
        plightVerifier = await PlightVerifierFactory.deploy(verifierAddress);
        await plightVerifier.waitForDeployment();
    });

    it("Should verify a valid proof", async function () {
        // Load generated proof (needs to be generated by circuits test first)
        const proofPath = path.join(__dirname, "../../circuits/proof.json");
        const publicPath = path.join(__dirname, "../../circuits/public.json");

        if (!fs.existsSync(proofPath) || !fs.existsSync(publicPath)) {
            console.log("Proof files not found. Creating dummy proof for structure test.");
            return; // Skip if no proof (or mock it)
        }

        const proofJson = JSON.parse(fs.readFileSync(proofPath, "utf-8"));
        const publicJson = JSON.parse(fs.readFileSync(publicPath, "utf-8"));

        // Format for Solidity: [a, b, c] encoded
        // Groth16 Proof from snarkjs:
        // pi_a: [str, str, str]
        // pi_b: [[str,str], [str,str], [str,str]]
        // pi_c: [str, str, str]

        const a = [proofJson.pi_a[0], proofJson.pi_a[1]];
        const b = [[proofJson.pi_b[0][1], proofJson.pi_b[0][0]], [proofJson.pi_b[1][1], proofJson.pi_b[1][0]]]; // Swap for solidity
        const c = [proofJson.pi_c[0], proofJson.pi_c[1]];

        const encodedProof = ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256[2]", "uint256[2][2]", "uint256[2]"],
            [a, b, c]
        );

        // Call Verify
        // Benchmark Gas (simulate transaction)
        const gasEstimate = await plightVerifier.verify.estimateGas(encodedProof, publicJson);
        console.log("Estimated Gas (Valid Proof):", gasEstimate.toString());

        const result = await plightVerifier.verify(encodedProof, publicJson);
        expect(result).to.be.true;
    });

    it("Should reject invalid public inputs", async function () {
        const proofPath = path.join(__dirname, "../../circuits/proof.json");
        const publicPath = path.join(__dirname, "../../circuits/public.json");

        if (!fs.existsSync(proofPath)) return;

        const proofJson = JSON.parse(fs.readFileSync(proofPath, "utf-8"));
        const publicJson = JSON.parse(fs.readFileSync(publicPath, "utf-8"));

        const a = [proofJson.pi_a[0], proofJson.pi_a[1]];
        const b = [[proofJson.pi_b[0][1], proofJson.pi_b[0][0]], [proofJson.pi_b[1][1], proofJson.pi_b[1][0]]];
        const c = [proofJson.pi_c[0], proofJson.pi_c[1]];

        const encodedProof = ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256[2]", "uint256[2][2]", "uint256[2]"],
            [a, b, c]
        );

        // Tamper Input
        const tamperedInputs = [...publicJson];
        tamperedInputs[0] = "123456789"; // Change chainId

        const result = await plightVerifier.verify(encodedProof, tamperedInputs);
        expect(result).to.be.false;
    });

    it("Should revert on invalid input length", async function () {
        const dummyProof = ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256[2]", "uint256[2][2]", "uint256[2]"],
            [[1, 2], [[3, 4], [5, 6]], [7, 8]]
        );
        const shortInputs = [1, 2, 3];

        await expect(
            plightVerifier.verify(dummyProof, shortInputs)
        ).to.be.revertedWith("Invalid input length: expected 19");
    });
});
